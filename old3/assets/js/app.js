class DocumentationApp {
    constructor() {
        this.currentPage = null;
        this.navigationData = {};
        this.searchIndex = [];

        this.init();
    }

    async init() {
        await this.loadNavigation();
        this.setupEventListeners();
        this.initializeTheme();
        this.loadDefaultPage();
    }

    async loadNavigation() {
        try {
            // Load the main categories from the pages folder
            const categories = await this.fetchCategories();

            for (const category of categories) {
                await this.loadCategoryData(category);
            }

            this.renderNavigation();
        } catch (error) {
            console.error('Error loading navigation:', error);
        }
    }

    async fetchCategories() {
        // Since we can't directly read directories in a browser, we'll define the known categories
        // In a real deployment, this could be generated by a build script
        return [
            'Getting Started',
            'Community Bridge',
            'Examples'
        ];
    }

    async loadCategoryData(category) {
        try {
            // Load the index.md file if it exists
            let indexContent = null;
            try {
                indexContent = await this.fetchFile(`pages/${category}/index.md`);
            } catch (e) {
                console.log(`No index.md found for ${category}`);
            }

            // Load the toc.json file
            let tocData = [];
            try {
                const tocResponse = await this.fetchFile(`pages/${category}/toc.json`);
                tocData = JSON.parse(tocResponse);
            } catch (e) {
                console.log(`No toc.json found for ${category}`);
            }

            this.navigationData[category] = {
                indexContent,
                toc: tocData,
                subcategories: {}
            };            // Load subcategory data
            for (const item of tocData) {
                await this.loadTocItem(category, item);
            }

            // Index content for search
            this.indexContentForSearch(category, indexContent, tocData);

        } catch (error) {            console.error(`Error loading category ${category}:`, error);
        }
    }

    async loadTocItem(category, item) {
        if (item.type === 'folder') {
            await this.loadSubcategoryData(category, item.name);
        } else if (item.type === 'category' && item.children) {
            // Recursively load items from nested categories
            for (const childItem of item.children) {
                await this.loadTocItem(category, childItem);
            }
        }
    }

    async loadSubcategoryData(category, subcategory) {
        try {
            const path = `pages/${category}/${subcategory}`;

            // Try to load markdown file first
            let markdownContent = null;
            try {
                markdownContent = await this.fetchFile(`${path}/${subcategory.toLowerCase()}.md`);
            } catch (e) {
                // If no markdown, try to load JSON data
                try {
                    const jsonResponse = await this.fetchFile(`${path}/${subcategory.toLowerCase()}.json`);
                    const jsonData = JSON.parse(jsonResponse);

                    // Try to load the module's toc.json
                    let moduleToc = null;
                    try {
                        const tocResponse = await this.fetchFile(`${path}/toc.json`);
                        moduleToc = JSON.parse(tocResponse);
                    } catch (tocError) {
                        console.log(`No toc.json found for ${category}/${subcategory}`);
                    }

                    this.navigationData[category].subcategories[subcategory] = {
                        type: 'json',
                        data: jsonData,
                        toc: moduleToc
                    };

                    // Index JSON functions for search
                    this.indexJsonForSearch(category, subcategory, jsonData);
                } catch (e2) {
                    console.log(`No content found for ${category}/${subcategory}`);
                }
                return;
            }

            // For markdown content, also try to load module toc.json
            let moduleToc = null;
            try {
                const tocResponse = await this.fetchFile(`${path}/toc.json`);
                moduleToc = JSON.parse(tocResponse);
            } catch (tocError) {
                console.log(`No toc.json found for ${category}/${subcategory}`);
            }

            this.navigationData[category].subcategories[subcategory] = {
                type: 'markdown',
                content: markdownContent,
                toc: moduleToc
            };

            // Index markdown for search
            this.indexMarkdownForSearch(category, subcategory, markdownContent);

        } catch (error) {
            console.error(`Error loading subcategory ${category}/${subcategory}:`, error);
        }
    }

    async fetchFile(path) {
        const response = await fetch(path);
        if (!response.ok) {
            throw new Error(`Failed to fetch ${path}: ${response.status}`);
        }
        return await response.text();
    }

    indexContentForSearch(category, content, toc) {
        if (content) {
            this.searchIndex.push({
                type: 'page',
                category,
                title: category,
                content: content,
                path: `${category}`
            });
        }

        toc.forEach(item => {
            this.searchIndex.push({
                type: 'section',
                category,
                title: item.title || item.name,
                description: item.description || '',
                path: `${category}/${item.name}`
            });
        });
    }

    indexMarkdownForSearch(category, subcategory, content) {
        this.searchIndex.push({
            type: 'markdown',
            category,
            subcategory,
            title: subcategory,
            content: content,
            path: `${category}/${subcategory}`
        });
    }

    indexJsonForSearch(category, subcategory, data) {
        // Index client functions
        if (data.clientFunctions) {
            data.clientFunctions.forEach(func => {
                this.searchIndex.push({
                    type: 'function',
                    category,
                    subcategory,
                    title: func.name,
                    description: func.description,
                    syntax: func.syntax,
                    path: `${category}/${subcategory}#${func.name}`
                });
            });
        }

        // Index server functions
        if (data.serverFunctions) {
            data.serverFunctions.forEach(func => {
                this.searchIndex.push({
                    type: 'function',
                    category,
                    subcategory,
                    title: func.name,
                    description: func.description,
                    syntax: func.syntax,
                    path: `${category}/${subcategory}#${func.name}`
                });
            });
        }
    }    renderNavigation() {
        const navContainer = document.getElementById('navigation');
        navContainer.innerHTML = '';

        Object.keys(this.navigationData).forEach(category => {
            const categoryData = this.navigationData[category];

            const categoryElement = document.createElement('div');
            categoryElement.className = 'nav-section';

            const categoryTitle = document.createElement('div');
            categoryTitle.className = 'nav-section-title';
            categoryTitle.innerHTML = `
                <span class="nav-title-text">${category}</span>
                <i class="fas fa-chevron-down nav-toggle-icon"></i>
            `;

            // Make category title clickable to load page
            const titleText = categoryTitle.querySelector('.nav-title-text');
            titleText.addEventListener('click', (e) => {
                e.stopPropagation();
                this.loadPage(category);
            });

            // Make the whole title area toggle subsection visibility
            categoryTitle.addEventListener('click', () => this.toggleNavSection(categoryElement));

            categoryElement.appendChild(categoryTitle);            // Add subcategories
            if (categoryData.toc && categoryData.toc.length > 0) {
                const subsection = document.createElement('div');
                subsection.className = 'nav-subsection';

                this.renderNavItems(categoryData.toc, subsection, category);

                categoryElement.appendChild(subsection);

                // Start with Community Bridge expanded by default
                if (category === 'Community Bridge') {
                    categoryElement.classList.add('expanded');
                }
            }

            navContainer.appendChild(categoryElement);
        });    }

    renderNavItems(items, container, category, level = 0) {
        items.forEach(item => {
            if (item.type === 'category' && item.children) {
                // Create a nested category
                const categoryItem = document.createElement('div');
                categoryItem.className = 'nav-category-item';
                categoryItem.innerHTML = `
                    <div class="nav-category-title">
                        <span>${item.title || item.name}</span>
                        <i class="fas fa-chevron-down nav-category-toggle"></i>
                    </div>
                `;

                const nestedContainer = document.createElement('div');
                nestedContainer.className = 'nav-nested-items';

                // Recursively render children
                this.renderNavItems(item.children, nestedContainer, category, level + 1);

                categoryItem.appendChild(nestedContainer);

                // Add toggle functionality
                const categoryTitle = categoryItem.querySelector('.nav-category-title');
                const toggleIcon = categoryItem.querySelector('.nav-category-toggle');

                categoryTitle.addEventListener('click', () => {
                    if (nestedContainer.classList.contains('expanded')) {
                        nestedContainer.classList.remove('expanded');
                        toggleIcon.style.transform = 'rotate(0deg)';
                    } else {
                        nestedContainer.classList.add('expanded');
                        toggleIcon.style.transform = 'rotate(180deg)';
                    }
                });

                // Start with Modules expanded by default
                if (item.name === 'Modules') {
                    nestedContainer.classList.add('expanded');
                    toggleIcon.style.transform = 'rotate(180deg)';
                }

                container.appendChild(categoryItem);
            } else {
                // Regular navigation item
                const navItem = document.createElement('div');
                navItem.className = 'nav-item';
                navItem.innerHTML = `<span>${item.title || item.name}</span>`;
                navItem.addEventListener('click', () => this.loadPage(category, item.name));
                container.appendChild(navItem);
            }
        });
    }

    toggleNavSection(categoryElement) {
        const subsection = categoryElement.querySelector('.nav-subsection');
        const toggleIcon = categoryElement.querySelector('.nav-toggle-icon');

        if (!subsection) return;

        if (categoryElement.classList.contains('expanded')) {
            categoryElement.classList.remove('expanded');
            toggleIcon.style.transform = 'rotate(0deg)';
        } else {
            categoryElement.classList.add('expanded');
            toggleIcon.style.transform = 'rotate(180deg)';
        }
    }

    async loadPage(category, subcategory = null) {
        const contentContainer = document.getElementById('mainContent');
        contentContainer.innerHTML = '<div class="loading">Loading...</div>';        try {
            let content = '';
            let moduleToc = null;

            if (!subcategory) {
                // Load category index page
                const categoryData = this.navigationData[category];
                if (categoryData && categoryData.indexContent) {
                    content = this.renderMarkdown(categoryData.indexContent);
                } else {
                    content = this.renderCategoryOverview(category);
                }
            } else {
                // Load subcategory page
                const subcategoryData = this.navigationData[category]?.subcategories[subcategory];
                if (subcategoryData) {
                    moduleToc = subcategoryData.toc;
                    if (subcategoryData.type === 'markdown') {
                        content = this.renderMarkdown(subcategoryData.content);
                    } else if (subcategoryData.type === 'json') {
                        content = this.renderJsonData(subcategoryData.data);
                    }
                } else {
                    content = '<h1>Page Not Found</h1><p>The requested page could not be found.</p>';
                }
            }            contentContainer.innerHTML = content;
            this.updateActiveNavItem(category, subcategory);

            // Generate TOC after content is inserted
            this.generateTableOfContents(moduleToc);

            // Initialize scroll animations for cards
            this.initializeScrollAnimations();

            // Highlight code blocks
            if (window.Prism) {
                Prism.highlightAll();
            }

        } catch (error) {
            console.error('Error loading page:', error);
            contentContainer.innerHTML = '<h1>Error</h1><p>An error occurred while loading the page.</p>';
        }
    }

    renderMarkdown(markdownContent) {
        if (window.marked) {
            return marked.parse(markdownContent);
        } else {
            // Fallback: simple markdown-like rendering
            return markdownContent
                .replace(/^# (.*$)/gim, '<h1>$1</h1>')
                .replace(/^## (.*$)/gim, '<h2>$1</h2>')
                .replace(/^### (.*$)/gim, '<h3>$1</h3>')
                .replace(/```([^`]+)```/g, '<pre><code>$1</code></pre>')
                .replace(/`([^`]+)`/g, '<code>$1</code>')
                .replace(/\n\n/g, '</p><p>')
                .replace(/^/, '<p>')
                .replace(/$/, '</p>');
        }
    }    renderCategoryOverview(category) {
        const categoryData = this.navigationData[category];
        let html = `<h1>${category}</h1>`;

        if (categoryData.toc && categoryData.toc.length > 0) {
            html += '<div class="category-overview">';
            html += this.renderCategoryCards(categoryData.toc);
            html += '</div>';
        }

        return html;
    }

    renderCategoryCards(items) {
        let html = '';

        items.forEach(item => {
            if (item.type === 'category' && item.children) {
                // Render category header
                html += `<h2 class="category-section-title">${item.title || item.name}</h2>`;
                html += '<div class="cards-grid">';

                // Render cards for children
                item.children.forEach(child => {
                    html += this.renderCard(child);
                });

                html += '</div>';
            } else {
                // Direct item - render as single card
                if (!html.includes('<div class="cards-grid">')) {
                    html += '<div class="cards-grid">';
                }
                html += this.renderCard(item);
            }
        });

        if (html.includes('<div class="cards-grid">') && !html.endsWith('</div>')) {
            html += '</div>';
        }

        return html;
    }

    renderCard(item) {
        const cardTitle = item.title || item.name;
        const cardIcon = item.icon || '📄';
        const cardDescription = item.description || 'Click to explore this module and its functions.';

        return `
            <div class="doc-card" onclick="app.loadPage('${item.category || 'Community Bridge'}', '${item.name}')">
                <div class="card-header">
                    <div class="card-icon">${cardIcon}</div>
                    <div class="card-title">${cardTitle}</div>
                </div>
                <div class="card-description">
                    ${cardDescription}
                </div>                <div class="card-footer">
                    <span class="card-action">Explore →</span>
                </div>
            </div>
        `;
    }

    renderJsonData(data) {
        let html = `
            <h1 id="overview">${data.icon || '📄'} ${data.name}</h1>
            <p>${data.description}</p>
        `;        // Track used function names and global counter for proper ID generation
        const usedFunctionNames = new Map(); // Store name -> first occurrence index
        let globalCounter = 0;

        if (data.clientFunctions && data.clientFunctions.length > 0) {
            html += '<h2 id="client-functions">Client Functions</h2>';
            data.clientFunctions.forEach(func => {
                html += this.renderFunction(func, usedFunctionNames, globalCounter);
                globalCounter++;
            });
        }

        if (data.serverFunctions && data.serverFunctions.length > 0) {
            html += '<h2 id="server-functions">Server Functions</h2>';
            data.serverFunctions.forEach(func => {
                html += this.renderFunction(func, usedFunctionNames, globalCounter);
                globalCounter++;
            });
        }        return html;
    }

    renderFunction(func, usedFunctionNames = new Map(), globalCounter = 0) {
        // Generate ID to match TOC format
        const baseName = func.name.toLowerCase();
        let functionId;
        
        if (usedFunctionNames.has(baseName)) {
            // This function name was used before - add the current counter
            functionId = `function-${baseName}-${globalCounter}`;
        } else {
            // First occurrence - no number, but remember this name
            functionId = `function-${baseName}`;
            usedFunctionNames.set(baseName, globalCounter);
        }

        let html = `
            <div class="function-card" id="${functionId}">
                <div class="function-header">
                    <div class="function-name">${func.name}</div>
                    <div class="function-description">${func.description}</div>
                </div>
                <div class="function-syntax">
                    <code>${func.syntax}</code>
                </div>
        `;

        if (func.parameters && func.parameters.length > 0) {
            html += `
                <div class="function-section">
                    <h4>Parameters</h4>
                    <ul class="parameter-list">
            `;
            func.parameters.forEach(param => {
                html += `
                    <li class="parameter-item">
                        <span class="param-name">${param.name}</span>
                        <span class="param-type">(${param.type})</span>
                        <div>${param.description}</div>
                    </li>
                `;
            });
            html += '</ul></div>';
        }

        if (func.returns && func.returns.length > 0) {
            html += `
                <div class="function-section">
                    <h4>Returns</h4>
                    <ul class="return-list">
            `;
            func.returns.forEach(ret => {
                html += `
                    <li class="return-item">
                        <span class="return-type">${ret.type}</span>
                        <div>${ret.description}</div>
                    </li>
                `;
            });
            html += '</ul></div>';
        }

        if (func.example) {
            html += `
                <div class="function-section">
                    <h4>Example</h4>
                    <pre><code class="language-lua">${func.example}</code></pre>
                </div>
            `;
        }

        html += '</div>';
        return html;
    }    updateActiveNavItem(category, subcategory) {
        // Remove all active classes
        document.querySelectorAll('.nav-section-title, .nav-item').forEach(item => {
            item.classList.remove('active');
        });

        // Add active class to current items
        const categoryElements = document.querySelectorAll('.nav-section-title');
        categoryElements.forEach(element => {
            const titleText = element.querySelector('.nav-title-text');
            if (titleText && titleText.textContent === category) {
                element.classList.add('active');

                // Ensure the section is expanded when navigating to it
                const navSection = element.parentElement;
                if (!navSection.classList.contains('expanded')) {
                    this.toggleNavSection(navSection);
                }

                if (subcategory) {
                    const subsection = element.parentElement.querySelector('.nav-subsection');
                    if (subsection) {
                        const navItems = subsection.querySelectorAll('.nav-item');
                        navItems.forEach(navItem => {
                            const itemText = navItem.querySelector('span').textContent;
                            if (itemText === subcategory || itemText.includes(subcategory)) {
                                navItem.classList.add('active');                            }
                        });
                    }
                }
            }
        });
    }

    generateTableOfContents(moduleToc = null) {
        const tocContainer = document.getElementById('tocContent');

        // If we have a module TOC, use that instead of auto-generating
        if (moduleToc && moduleToc.items) {
            let tocHtml = '';

            const renderTocItems = (items, level = 0) => {
                items.forEach(item => {
                    const indent = level * 1; // 1rem per level
                    const levelClass = level === 0 ? 'toc-h2' : 'toc-h3';

                    tocHtml += `
                        <a href="${item.anchor}" class="toc-item ${levelClass}" style="margin-left: ${indent}rem;">
                            ${item.title}
                        </a>
                    `;

                    // Render children if they exist
                    if (item.children && item.children.length > 0) {
                        renderTocItems(item.children, level + 1);
                    }
                });
            };

            renderTocItems(moduleToc.items);
            tocContainer.innerHTML = tocHtml;
        } else {
            // Fallback to auto-generation for markdown pages or when no TOC is available
            this.generateAutoTableOfContents();
        }        // Add smooth scrolling with proper positioning
        setTimeout(() => {
            document.querySelectorAll('.toc-item').forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    const href = link.getAttribute('href');
                    const targetId = href.substring(1); // Remove the #
                    const targetElement = document.getElementById(targetId);                    if (targetElement) {
                        // Improved scroll positioning - accounts for header height + buffer
                        const headerHeight = 80; // Header height from CSS
                        const buffer = 20; // Extra space for better visibility
                        const elementPosition = targetElement.offsetTop - headerHeight - buffer;

                        window.scrollTo({
                            top: Math.max(0, elementPosition), // Ensure we don't scroll above page top
                            behavior: 'smooth'
                        });

                        // No highlight effect - removed as requested
                    } else {
                        console.warn(`Target element not found for ID: ${targetId}. Available IDs:`,
                            Array.from(document.querySelectorAll('#mainContent [id]')).map(el => el.id));
                    }
                });
            });
        }, 100);
    }

    generateAutoTableOfContents() {
        const tocContainer = document.getElementById('tocContent');

        // Get main headings and function cards
        const headings = document.querySelectorAll('#mainContent h1, #mainContent h2, #mainContent h3');
        const functionCards = document.querySelectorAll('#mainContent .function-card');

        let tocItems = [];

        // Add main headings
        headings.forEach((heading, index) => {
            // Skip headings that are subsections like "Parameters", "Returns", "Example"
            const text = heading.textContent.trim();
            const skipHeadings = ['Parameters', 'Returns', 'Example', 'Client Functions', 'Server Functions'];

            if (!skipHeadings.includes(text)) {
                const id = heading.id || `heading-${index}`;
                heading.id = id;

                const level = heading.tagName.toLowerCase();
                tocItems.push({
                    id: id,
                    text: text,
                    level: level,
                    type: 'heading'
                });
            }
        });

        // Add function names from function cards
        functionCards.forEach((card, index) => {
            const functionName = card.querySelector('.function-name');
            if (functionName) {
                const text = functionName.textContent.trim();
                const id = card.id || `function-${index}`;
                card.id = id;

                tocItems.push({
                    id: id,
                    text: text,
                    level: 'function',
                    type: 'function'
                });
            }
        });

        if (tocItems.length === 0) {
            tocContainer.innerHTML = '<p>No content found</p>';
            return;
        }

        let tocHtml = '';
        tocItems.forEach(item => {
            const levelClass = item.type === 'function' ? 'toc-function' : `toc-${item.level}`;
            tocHtml += `
                <a href="#${item.id}" class="toc-item ${levelClass}">
                    ${item.type === 'function' ? '🔧 ' : ''}${item.text}
                </a>
            `;        });

        tocContainer.innerHTML = tocHtml;

        // Add smooth scrolling and active state tracking
        document.querySelectorAll('.toc-item').forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                const targetId = link.getAttribute('href').substring(1);
                const targetElement = document.getElementById(targetId);
                if (targetElement) {
                    targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            });
        });
    }

    setupEventListeners() {
        // Theme toggle
        const themeToggle = document.getElementById('themeToggle');
        themeToggle.addEventListener('click', () => this.toggleTheme());

        // Search functionality
        const searchInput = document.getElementById('searchInput');
        searchInput.addEventListener('input', (e) => this.handleSearch(e.target.value));
        searchInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                this.showSearchResults(e.target.value);
            }
        });

        // Search modal
        const searchModal = document.getElementById('searchModal');
        const closeSearch = document.getElementById('closeSearch');
        closeSearch.addEventListener('click', () => this.hideSearchModal());

        searchModal.addEventListener('click', (e) => {
            if (e.target === searchModal) {
                this.hideSearchModal();
            }
        });

        // ESC key to close search
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                this.hideSearchModal();
            }
        });
    }

    toggleTheme() {
        const body = document.body;
        const themeToggle = document.getElementById('themeToggle');
        const icon = themeToggle.querySelector('i');

        if (body.classList.contains('dark-theme')) {
            body.classList.remove('dark-theme');
            icon.className = 'fas fa-moon';
            localStorage.setItem('theme', 'light');
        } else {
            body.classList.add('dark-theme');
            icon.className = 'fas fa-sun';
            localStorage.setItem('theme', 'dark');
        }
    }

    initializeTheme() {
        const savedTheme = localStorage.getItem('theme');
        const body = document.body;
        const themeToggle = document.getElementById('themeToggle');
        const icon = themeToggle.querySelector('i');

        if (savedTheme === 'light') {
            body.classList.remove('dark-theme');
            icon.className = 'fas fa-moon';
        } else {
            // Default to dark theme
            body.classList.add('dark-theme');
            icon.className = 'fas fa-sun';
        }
    }

    handleSearch(query) {
        if (query.length < 2) {
            return;
        }

        // Simple debouncing
        clearTimeout(this.searchTimeout);
        this.searchTimeout = setTimeout(() => {
            this.performSearch(query);
        }, 300);
    }

    performSearch(query) {
        const results = this.searchIndex.filter(item => {
            const searchText = `${item.title} ${item.description || ''} ${item.content || ''}`.toLowerCase();
            return searchText.includes(query.toLowerCase());
        });

        if (results.length > 0) {
            this.showSearchResults(query, results);
        }
    }

    showSearchResults(query, results = null) {
        if (!results) {
            results = this.searchIndex.filter(item => {
                const searchText = `${item.title} ${item.description || ''} ${item.content || ''}`.toLowerCase();
                return searchText.includes(query.toLowerCase());
            });
        }

        const searchModal = document.getElementById('searchModal');
        const searchResults = document.getElementById('searchResults');

        if (results.length === 0) {
            searchResults.innerHTML = '<p>No results found.</p>';
        } else {
            let resultsHtml = '';
            results.slice(0, 10).forEach(result => {
                resultsHtml += `
                    <div class="search-result-item" data-path="${result.path}">
                        <div class="search-result-title">${result.title}</div>
                        <div class="search-result-path">${result.category}${result.subcategory ? ' > ' + result.subcategory : ''}</div>
                        <div class="search-result-description">${result.description || result.type}</div>
                    </div>
                `;
            });
            searchResults.innerHTML = resultsHtml;

            // Add click handlers for search results
            document.querySelectorAll('.search-result-item').forEach(item => {
                item.addEventListener('click', () => {
                    const path = item.getAttribute('data-path').split('/');
                    const category = path[0];
                    const subcategory = path[1];

                    this.loadPage(category, subcategory);
                    this.hideSearchModal();

                    // Scroll to specific function if hash is present
                    const hash = item.getAttribute('data-path').split('#')[1];
                    if (hash) {
                        setTimeout(() => {
                            const element = document.getElementById(hash);
                            if (element) {
                                element.scrollIntoView({ behavior: 'smooth' });
                            }
                        }, 100);
                    }
                });
            });
        }

        searchModal.classList.remove('hidden');
    }

    hideSearchModal() {
        const searchModal = document.getElementById('searchModal');
        searchModal.classList.add('hidden');
    }    loadDefaultPage() {
        // Load the first category by default
        const firstCategory = Object.keys(this.navigationData)[0];
        if (firstCategory) {
            this.loadPage(firstCategory);
        }    }

    initializeScrollAnimations() {
        let ticking = false;

        const handleScroll = () => {
            if (!ticking) {
                requestAnimationFrame(() => {
                    const cards = document.querySelectorAll('.doc-card');

                    cards.forEach((card) => {
                        const rect = card.getBoundingClientRect();
                        const windowHeight = window.innerHeight;

                        // Check if card is in the center portion of the viewport
                        const isInView = rect.top < windowHeight * 0.8 && rect.bottom > windowHeight * 0.2;

                        if (isInView) {
                            card.classList.add('in-view');
                        } else {
                            card.classList.remove('in-view');
                        }
                    });

                    ticking = false;
                });
                ticking = true;
            }
        };

        // Remove existing listener
        if (this.scrollHandler) {
            window.removeEventListener('scroll', this.scrollHandler);
        }

        // Add scroll listener
        this.scrollHandler = handleScroll;
        window.addEventListener('scroll', this.scrollHandler, { passive: true });

        // Trigger initial call
        handleScroll();
    }
}

// Initialize the app when the DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    new DocumentationApp();
});
